{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"StateMachineBehavior\r\n====================\r\n\r\n[![Build Status](https://secure.travis-ci.org/willdurand/StateMachineBehavior.png?branch=master)](http://travis-ci.org/willdurand/StateMachineBehavior)\r\n\r\nThis behavior adds a finite state machine to your model.\r\n\r\n\r\n### Configuration ###\r\n\r\n``` xml\r\n<behavior name=\"state_machine\">\r\n    <parameter name=\"states\" value=\"draft, rejected, unpublished, published\" />\r\n\r\n    <parameter name=\"initial_state\" value=\"draft\" />\r\n\r\n    <parameter name=\"transition\" value=\"draft to published with publish\" />\r\n    <parameter name=\"transition\" value=\"draft to rejected with reject\" />\r\n    <parameter name=\"transition\" value=\"published to unpublished with unpublish\" />\r\n    <parameter name=\"transition\" value=\"unpublished to published with publish\" />\r\n\r\n    <!-- Optional parameters -->\r\n    <parameter name=\"state_column\" name=\"state\" />\r\n</behavior>\r\n```\r\n\r\nThe **state_machine** behavior requires three parameters to work:\r\n\r\n* `states`: a finite set of states as comma separated values;\r\n* `initial_state`: the initial state, part of set of states;\r\n* `transition`: a set of transitions. As you can see, you can add as many `transition` parameters as you want.\r\n\r\nEach transition has to follow this pattern:\r\n\r\n    STATE_1 to STATE_2 with SYMBOL\r\n\r\nA `symbol`, which is part of the Finite State Machine's terminology, can be considered as an event triggered\r\non your model object.\r\n\r\n\r\n###Â ActiveRecord API ###\r\n\r\nThe behavior will generate the following constants which represent the available states of your object:\r\n\r\n* `ObjectModel::STATE_DRAFT`\r\n* `ObjectModel::STATE_REJECTED`\r\n* `ObjectModel::STATE_UNPUBLISHED`\r\n* `ObjectModel::STATE_PUBLISHED`\r\n\r\nYou can get the current state of your object:\r\n\r\n    getState()\r\n\r\nOr get an array with all available states:\r\n\r\n    getAvailableStates()\r\n\r\nMost of the time, you would like to display these states. Thanks to two\r\nconvenient methods, it's really easy:\r\n\r\n    getHumanizedState() // 'Draft', or 'Rejected', or 'Unpublished', or 'Published'\r\n\r\n    ObjectModel::getHumanizedStates()\r\n    // array(\r\n    //  0 => 'Draft',\r\n    //  1 => 'Rejected',\r\n    //  2 => 'Unpublished',\r\n    //  3 => 'Published',\r\n    // )\r\n\r\nThe behavior will also generate a set of issers:\r\n\r\n    isDraft()\r\n\r\n    isRejected()\r\n\r\n    isPublished()\r\n\r\n    isUnpublished()\r\n\r\nBut the most interesting part is the implemenation of the FSM itself.\r\nFirst you have methods to determine whether you can perform, or not a transition based\r\non the current model's state:\r\n\r\n    canPublish()\r\n\r\n    canReject()\r\n\r\n    canUnpublish()\r\n\r\nIt will also generate a set of methods for each `symbol`:\r\n\r\n    publish(PropelPDO $con = null)\r\n\r\n    unpublish(PropelPDO $con = null)\r\n\r\n    reject(PropelPDO $con = null)\r\n\r\n\r\nTo handle custom logic, new hooks are created.\r\nThe methods below should return a boolean value, and can act as **guards** (which is not part\r\nof the FSM's terminology).\r\n\r\n    prePublish(PropelPDO $con = null)\r\n\r\n    preUnpublish(PropelPDO $con = null)\r\n\r\n    preReject(PropelPDO $con = null)\r\n\r\nThe methods below should contain your own logic depending on each state, and your business.\r\n\r\n    onPublish(PropelPDO $con = null)\r\n\r\n    onUnpublish(PropelPDO $con = null)\r\n\r\n    onReject(PropelPDO $con = null)\r\n\r\nThe methods below allow to execute code once the transition is executed.\r\n\r\n    postPublish(PropelPDO $con = null)\r\n\r\n    postUnpublish(PropelPDO $con = null)\r\n\r\n    postReject(PropelPDO $con = null)\r\n\r\n\r\n### ActiveQuery API ###\r\n\r\nTo be defined.\r\n\r\n\r\n### Usage ###\r\n\r\nLet's say we have a `Post` model class which represents an entry in a blog engine.\r\nWhen we create a new post, its initial state is `draft` because we don't want to publish\r\nit immediately.\r\nAs a `draft`, you can decide to publish your new post. Its state is now `published`.\r\nOnce `published`, you may want to unpublish it for some reasons. Then, its state is `unpublished`.\r\nThe last possibily is to republish an `unpublished` post. The new state is `published`.\r\n\r\nWe have three different states (`draft`, `published`, `unpublished`), and three transitions:\r\n\r\n* `draft` to `published`\r\n* `published` to `unpublished`\r\n* `unpublished` to `published`\r\n\r\nWe can define the following configuration:\r\n\r\n``` xml\r\n<table name=\"post\">\r\n    <!-- some columns -->\r\n\r\n    <behavior name=\"state_machine\">\r\n        <parameter name=\"states\" value=\"draft, unpublished, published\" />\r\n\r\n        <parameter name=\"initial_state\" value=\"draft\" />\r\n\r\n        <parameter name=\"transition\" value=\"draft to published with publish\" />\r\n        <parameter name=\"transition\" value=\"published to unpublished with unpublish\" />\r\n        <parameter name=\"transition\" value=\"unpublished to published with publish\" />\r\n    </behavior>\r\n</table>\r\n```\r\n\r\nHere is a workflow:\r\n\r\n``` php\r\n<?php\r\n\r\n$post = new Post();\r\n\r\n$post->getState();              // Post::STATE_DRAFT\r\n$post->getAvailableStates();    // Post::STATE_DRAFT, Post::STATE_UNPUBLISHED, Post::STATE_PUBLISHED\r\n\r\n$post->isDraft();               // true\r\n$post->isPublished();           // false\r\n$post->isUnpublished();         // false\r\n\r\n$post->canPublish();            // true\r\n$post->canUnpublish();          // false\r\n\r\n$post->unpublish();             // throw a LogicException, no transition found from draft to unpublished\r\n\r\n// Let's publish this post\r\n// This is the first transition in the scenario above\r\n$post->publish()->save();\r\n\r\n$post->isDraft();               // false\r\n$post->isPublished();           // true\r\n$post->isUnpublished();         // false\r\n\r\n$post->canPublish();            // false\r\n$post->canUnpublish();          // true\r\n\r\n$post->publish();               // throw a LogicException, the post is already published\r\n\r\n// Let's unpublish this post\r\n// This is the second transition in the scenario above\r\n$post->unpublish()->save();\r\n\r\n$post->isDraft();               // false\r\n$post->isPublished();           // false\r\n$post->isUnpublished();         // true\r\n\r\n$post->canPublish();            // true\r\n$post->canUnpublish();          // false\r\n\r\n$post->unpublish();             // throw a LogicException, the post is already unpublished\r\n\r\n// Let's (re)publish this post\r\n// This is the last transition in the scenario above\r\n$post->publish()->save();\r\n\r\n$post->isDraft();               // false\r\n$post->isPublished();           // true\r\n$post->isUnpublished();         // false\r\n\r\n$post->canPublish();            // false\r\n$post->canUnpublish();          // true\r\n```\r\n\r\nNow imagine we have authors linked to each post, and once a post is published,\r\nwe notify the post's author by email. Thanks to new hooks, it's\r\nreally easy to extend things:\r\n\r\n``` php\r\n<?php\r\n\r\nclass Post extends BasePost\r\n{\r\n    // Assuming we have a mail manager which is able to send emails,\r\n    // and that we injected it before.\r\n    private $mailManager;\r\n\r\n    public function onPublish(PropelPDO $con = null)\r\n    {\r\n        $this->mailManager->postPublished(\r\n            $this->getAuthor(),\r\n            $this->getTitle()\r\n        );\r\n    }\r\n}\r\n```\r\n\r\nUse case in a controller:\r\n\r\n``` php\r\n<?php\r\n\r\nclass PostController extends Controller\r\n{\r\n    public function newAction()\r\n    {\r\n        // handle a form, etc to create a new Post\r\n    }\r\n\r\n    public function publishAction(Post $post)\r\n    {\r\n        try {\r\n            $post->publish()->save();\r\n        } catch (\\LogicException $e) {\r\n            // handle the exception as you wish\r\n        }\r\n    }\r\n\r\n    public function unpublishAction(Post $post)\r\n    {\r\n        try {\r\n            $post->unpublish()->save();\r\n        } catch (\\LogicException $e) {\r\n            // handle the exception as you wish\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Known Limitations ###\r\n\r\n* You cannot use the `deleted` state;\r\n* You cannot use the `save`, or `delete` symbols.\r\n\r\nAt the moment, there is no built-in solution to handle these cases.\r\n\r\n\r\n### Combining Archivable Behavior\r\n\r\nThe [Archivable](http://www.propelorm.org/behaviors/archivable.html) behavior is\r\nuseful to copy a model object to an archival table. In other words, it acts as\r\na soft delete behavior but with better performance.\r\n\r\nIn your workflow, you may want to destroy your object for some reason. I say\r\n\"destroy\" because you can't use the `deleted` status, nor the `delete` symbol,\r\nbut it doesn't matter. Destroying an object is fine, but instead of hard\r\ndeleting it, you may want to soft delete it. That means you will rely on the\r\narchivable behavior.\r\n\r\nJust add it to your XML schema, rebuild both SQL, and model classes, and you're\r\ndone. At first glance, when you `destroy` your object, you will expect it\r\nto be hidden, but it's not the case. It just has the `destroyed` state.\r\n\r\nJust call the `delete()` termination method as usual, and your object will be\r\nautomatically archived. No much to do.\r\n","name":"Statemachinebehavior","google":"","tagline":"This behavior adds a finite state machine to your model."}